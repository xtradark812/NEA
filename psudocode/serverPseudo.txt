from json.decoder IMPORT JSONDecoder

IMPORT socket

IMPORT threading

IMPORT json

IMPORT sqlite3



from ui IMPORT OnlineList







#Set up TCP connection

SET server TO "127.0.0.1"

SET port TO 5555

SET s TO socket.socket(socket.AF_INET, socket.SOCK_STREAM)





SET clients TO []

SET battles TO []





DEFINE FUNCTION log(event,e=None): #Log function FOR debugging

    IF e != None:

        OUTPUT("ERROR |", event, e )

    ELSE:

        OUTPUT("log:", event)

    #Possibly save to file?





#Start server

TRY:

    s.bind((server,port))

    s.listen(2)

    log("Waiting FOR a connection")

except socket.error as e:

    str(e)

    log("error connecting",e)





DEFINE CLASS Database():

    DEFINE FUNCTION __init__(self):

        #init sqlite

        SET self.con TO sqlite3.connect('database.db')

        SET self.cursor TO self.con.cursor()



        #init Database

        self.initDatabase()

    

    DEFINE FUNCTION initDatabase(self):



        self.cursor.execute('''CREATE TABLE IF NOT EXISTS users

               (user_name text NOT NULL, password text, access text)''')



        self.cursor.execute('''CREATE TABLE IF NOT EXISTS accessTextures

               (access text NOT NULL, serializedData text)''')



        #self.createAccess("test",json.dumps({"standing":"","enemyStanding":"","background":"background01","crouching":"","enemyCrouching":"","walking":"","enemyWalking":"","jumping":"","enemyJumping":""}))



    DEFINE FUNCTION createUser(self,username,password,access):

        self.cursor.execute("INSERT INTO users VALUES (?,?,?)",[username,password,access])

        self.con.commit()

    

    DEFINE FUNCTION createAccess(self,name,data):

        self.cursor.execute("INSERT INTO accessTextures VALUES (?,?)",[name,data])

        self.con.commit()



    DEFINE FUNCTION getAcsess(self,username):

        SET self.cursor.execute("SELECT accessTextures.serializedData FROM accessTextures INNER JOIN users WHERE users.access TO accessTextures.access AND users.user_name TO (?)",[username])



        SET serializedData TO self.cursor.fetchone()



        RETURN serializedData[0]



    DEFINE FUNCTION checkCredintials(self,username,password):

        self.cursor.execute("SELECT user_name, password FROM users")

        SET data TO self.cursor.fetchall()

        FOR user IN data:

            IF user[0] EQUALS username and user[1] EQUALS password:

                RETURN True

        RETURN False



    DEFINE FUNCTION close(self):

        PASS





    

DEFINE CLASS Client:

    DEFINE FUNCTION __init__(self,user,addr):

        SET self.user TO user

        SET self.addr TO addr

        self.clientLog("initializing user "+"%s:%s" % addr)



        



        SET self.connected TO False

        SET self.BUFSIZ TO 1024

        SET self.username TO None

        SET self.loggedIn TO False

        

        #after set ammount of consecutive receive errors, server will close connection

        SET self.ecounter TO 0 



        SET self.pendingBattle TO False

        SET self.enemyUsername TO None

        SET self.battleSent TO False

        SET self.battleAccepted TO False

        SET self.pendingClient TO None

        SET self.requestedEnemy TO None

 



        SET self.x TO 0

        SET self.y TO 0 

        SET self.click TO None

        SET self.state TO "standing"

        SET self.orientation TO "R"

        SET self.hp TO 100



        SET mainThread TO threading.Thread(target=self.main)

        mainThread.start()





    DEFINE FUNCTION clientLog(self,events,e=None):

        IF e != None:

            OUTPUT(self.addr," ERROR |", events, e )

        ELSE:

            OUTPUT(self.addr," log:", events)



    DEFINE FUNCTION send(self,data):

        TRY:

            SET serialized_data TO json.dumps(data) #serialize data

            self.user.sendall(bytes(serialized_data, "utf8"))

        except Exception as e:

            self.clientLog("send error",e)



    DEFINE FUNCTION receive(self):

        

        SET decoder TO JSONDecoder()

        TRY:

            SET data TO self.user.recv(self.BUFSIZ).decode("utf8")

            IF not data:

                RETURN {"requestType":"clientDisconnect"}

            ELSE:

                

                SET response, index TO decoder.raw_decode(data) ### WAITS FOR DATA TO BE RETURNED

                IF response != None:

                    RETURN response

                ELSE:

                    log("error: No data recived")

                    RETURN {"requestType":None}

            

        except socket.timeout:

            RETURN {"requestType":"error","error":"socketTimeout"}

        except Exception as e:

            self.clientLog("receive error",e)

            RETURN {"requestType":"error","error":e}

            

    DEFINE FUNCTION requestHandler(self):

        self.user.settimeout(1) 

                

        IF self.pendingClient != None and self.battleAccepted EQUALS False:

            SET accept TO self.pendingClient.checkIfAccepted()

            IF accept:

                    self.clientLog("Both players have accepted the battle")

                    self.send({"requestType":"battleConfirm","battleAccepted":True,"enemyU":self.pendingClient.getUsername(),"startSide":"L"})

                    self.pendingClient.send({"requestType":"battleConfirm","battleAccepted":True,"enemyU":self.username,"startSide":"R"})

                    SET self.battleAccepted TO True

                    self.clientLog("creating battle")

                    startBattle(self.pendingClient,self) #starts battle

        

        SET data TO self.receive() 



        IF type(data) != dict or data["requestType"] EQUALS "error":

            self.ecounter +=1

            RETURN True

        ELSE:

            SET self.ecounter TO 0 

        

        IF self.ecounter > 30:

            self.clientLog("maximum receive errors, shutting down connection")

            RETURN False

    

        IF data["requestType"] EQUALS "clientDisconnect":

            RETURN False

        



        IF self.battleAccepted EQUALS True: 

            IF data["requestType"] EQUALS "posData":

                SET self.x TO data["x"]

                SET self.y TO data["y"]

                SET self.state TO data["state"]

                SET self.orientation TO data["orientation"]

                SET self.hp TO data["hp"]

                IF "clickPos" IN data:

                    SET self.click TO data["clickPos"]

        ELSE:

            IF data["requestType"] EQUALS "posData": #If user is still sending pos data when no battle exists, attempts to end the game

                self.send({"requestType":"gameOver"})



        IF self.battleSent EQUALS True and self.battleAccepted EQUALS False:

            IF data["requestType"]=="battleReq" and data["battleAccepted"]==True: 

                self.clientLog(self.username+" has accepted the battle")

                SET self.battleAccepted TO True

        IF data["requestType"] EQUALS "startBattle":

            self.clientLog("Battle reqest recieved")

            SET opponentU TO data["enemyU"]

            FOR client IN clients: #Searches list of connected clients

                IF client.getUsername() EQUALS opponentU and client.isconnected() EQUALS True and client.isLoggedIn() EQUALS True:

                    self.clientLog("attempting to start battle")

                    client.sendBattleRequest(self.username)

                    SET self.pendingClient TO client

        IF data["requestType"] EQUALS "getOnlineUsers":

            SET clientList TO []

            FOR client IN clients:

                IF client.isconnected() EQUALS True and client.isLoggedIn() EQUALS True:

                    clientList.append(client.getUsername())

            self.send({"requestType":"getOnlineUsers","onlineUsers":clientList})





        RETURN True

                

    DEFINE FUNCTION checkIfAccepted(self):

        RETURN self.battleAccepted



    DEFINE FUNCTION sendBattleRequest(self,enemyU):

        SET self.requestedEnemy TO enemyU

        SET battleReq TO {"requestType":"battleReq","enemyU":enemyU}

        self.send(battleReq)

        self.clientLog("sent battle request to "+self.username)

        SET self.battleSent TO True



    DEFINE FUNCTION main(self):

        OUTPUT("client initialised. beginning main loop",self.addr)

        IF self.loggedIn != True: 

            self.login()

        WHILE self.loggedIn and self.connected:

            SET self.connected TO self.requestHandler()

        

        self.disconnect()



    DEFINE FUNCTION disconnect(self):

            clients.remove(self)

            SET self.connected TO False

            self.clientLog([self.addr,"client disconnected"])

            self.user.close()

            SET self.loggedIn TO  False

            SET self.username TO None

            SET self.enemyUsername TO None



    DEFINE FUNCTION isconnected(self):

        RETURN self.connected

    

    DEFINE FUNCTION isLoggedIn(self):

        RETURN self.loggedIn

    

    DEFINE FUNCTION login(self): #pulled from previous messaging project

        #Then wait FOR login

        SET loginData TO self.receive()

        SET db TO Database()

        IF loginData["requestType"] EQUALS "loginRequest" and loginData["username"]!= "" and loginData["username"] not IN [client.username FOR client IN clients]: #Makes sure username is not blank or already connected

            SET username TO loginData["username"]

            SET password TO loginData["password"]



            IF db.checkCredintials(username,password):

                SET access TO db.getAcsess(username)



                SET loginReq TO {"requestType":"loginRequest","loginR":True,"access":access}

                self.send(loginReq)

                self.clientLog("confirmed login: "+username+" at"+"%s:%s" % self.addr)

                SET self.username TO username

                SET self.loggedIn TO True

                SET self.connected TO True

                

                db.close()

                RETURN True

            ELSE:

                SET loginReq TO {"requestType":"loginRequest","loginR":False,"reason":"Invalid username/password"}

                self.send(loginReq)

                RETURN False

 

    DEFINE FUNCTION getPos(self):

        IF self.click != None:

            SET data TO {"requestType":"posData","x":self.x,"y":self.y,"clickPos":self.click,"state":self.state,"orientation":self.orientation,"hp":self.hp}

            SET self.click TO None

            RETURN data

        ELSE:

            RETURN {"requestType":"posData","x":self.x,"y":self.y,"state":self.state,"orientation":self.orientation,"hp":self.hp}



    DEFINE FUNCTION getUsername(self):

        RETURN self.username



    DEFINE FUNCTION endBattle(self):

        self.send({"requestType":"gameOver"})

        SET self.battleAccepted TO False

        SET self.battleSent TO  False

        SET self.pendingBattle TO False

        SET self.pendingClient TO None

        SET self.requestedEnemy TO None



        SET self.x TO 0

        SET self.y TO 0 

        SET self.click TO None

        SET self.state TO "standing"

        SET self.orientation TO "R" 

        SET self.hp TO 100





DEFINE FUNCTION startBattle(client1,client2):

    SET battle TO Battle(client1,client2)

    battles.append(battle)







DEFINE CLASS Battle:

    DEFINE FUNCTION __init__(self,client1,client2):

        OUTPUT("initializing battle.")

        SET self.client1 TO client1

        SET self.client2 TO client2



        SET battleThread TO threading.Thread(target=self.sendPos)

        battleThread.start()





    DEFINE FUNCTION sendPos(self):

        SET self.battle TO  True

        WHILE self.client1.isconnected() EQUALS True and self.client2.isconnected() EQUALS True and self.battle EQUALS True:

            SET data1 TO self.client1.getPos()

            self.client2.send(data1)



            SET data2 TO self.client2.getPos()

            self.client1.send(data2)





            IF data1["hp"] <= 0 or data2["hp"] <= 0:

                SET self.battle TO False

            

        self.endBattle()



    DEFINE FUNCTION endBattle(self):

        self.client1.endBattle()

        self.client2.endBattle()

        OUTPUT("battle over")





### Old method of checking IF a player was hit, server sided. This is now done client sided.



    # IF "clickPos" IN data1: OLD

    SET #     data2["reduceHp"] TO self.checkClick(data1,data2)

    # ELSEIF "clickPos" IN data2:

    SET #     data1["reduceHp"] TO self.checkClick(data2,data1)

    

    # DEFINE FUNCTION checkClick(self,data1,data2): OLD 

    SET #     pos TO data1["clickPos"]

    #     OUTPUT(pos)

    SET #     x1 TO pos[0]

    SET #     y1 TO pos[1]

    SET #     x TO data2["x"]

    SET #     y TO data2["y"]

    SET #     state TO data2["state"]

    #     IF state != "crouching":

    #         IF  x-(self.width/2) <= x1 <= x + (self.width/2) and y-(self.height/2) <= y1 <= y + (self.height/2):

    #             RETURN 10

    #         ELSE:

    #             RETURN 0

    #     IF state EQUALS "crouching":

    #         IF  x-(self.width/2) <= x1 <= x + (self.width/2) and y-((self.height/2)/2) <= y1 <= y + ((self.height/2)/2):

    #             RETURN 10

    #         ELSE:

    #             RETURN 0







WHILE True:

    SET user, addr TO s.accept()

    OUTPUT("Incoming connection from:",addr)

    SET client TO Client(user,addr) #client should not be a thread

    clients.append(client)









    
