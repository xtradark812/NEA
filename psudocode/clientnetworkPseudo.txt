from json.decoder IMPORT JSONDecoder

IMPORT socket

IMPORT json

IMPORT threading



DEFINE FUNCTION log(event,e=None):

    IF e != None:

        OUTPUT("ERROR |", event, e )

    ELSE:

        OUTPUT("loog:", event)



DEFINE CLASS Network():

    DEFINE FUNCTION __init__(self):

        log("Initializing network")



        #init socket

        SET self.client TO socket.socket(socket.AF_INET,socket.SOCK_STREAM)

        SET self.server TO "127.0.0.1"



        #declare attributes

        SET self.port TO 5555

        SET self.addr TO (self.server,self.port)

        SET self.BUFSIZ TO 1024

        SET self.connected TO False

        SET self.username TO None

        SET self.access TO None

        SET self.enemyUsername TO None

        SET self.enemyData TO None

        SET self.data TO None

        SET self.onlineUsers TO []

        SET self.requestedEnemy TO None

        SET self.enemyClick TO None

        SET self.click TO None



        SET self.menu TO False

        SET self.battle TO False



        SET self.pendingBattle TO False

        SET self.pendingEnemy TO None

        SET self.startSide TO None





    DEFINE FUNCTION send(self,data):

        SET serialized_data TO json.dumps(data) #serialize data

        self.client.sendall(bytes(serialized_data, "utf8")) ### SENDS DATA TO SERVER 



    DEFINE FUNCTION receive(self):

        SET decoder TO JSONDecoder() #init JSON de-serealizer

        TRY:

            #Wait FOR data to be recived

            SET data TO self.client.recv(self.BUFSIZ).decode("utf8")

            IF not data or data EQUALS None:

                RETURN {"requestType":None}

            ELSE:

                SET response, index TO decoder.raw_decode(data) #De-serialize Dtata



                IF response != None:

                    RETURN response

                ELSE:

                    log("error desirealizing")

                    RETURN {"requestType":None}



        except socket.timeout:

            RETURN {"requestType":None}



        except Exception as e:

            log("error",e)

            RETURN {"requestType":None}



    DEFINE FUNCTION battleReceive(self):

        #This function is identical to the receive method, but includes a bug fix FOR when lots of data is being sent at once

        #when the client tries to send hundreds of json objects a seccond, sometimes the objects get stuck together

        #to solve this problem, this algorithim find exactly the data that is needed from each sent item, and strips off everything else

        #if it does not work (e.g. the server recives incomplete data like "123}"), it will call itself and try again

        SET decoder TO JSONDecoder()

        TRY:

            SET data TO self.client.recv(self.BUFSIZ).decode("utf8")

            IF not data or data EQUALS None:

                RETURN {"requestType":None}

            ELSE:



                SET i TO 0

                SET string TO False

                SET isdict TO False

                SET newData TO ""

                SET finalData TO ""

                FOR char IN data:

                    IF char EQUALS "{" and string EQUALS False:

                        SET newData TO data[i:]

                        SET isdict TO True

                    IF char EQUALS "}" and isdict EQUALS True and string EQUALS False:

                        SET finalData TO newData[:i+1]

                        SET string TO True

                    i+=1

                IF string EQUALS False:

                    SET tryAgain TO self.receive()

                    RETURN tryAgain

                SET response, index TO decoder.raw_decode(finalData) 

                IF response != None:

                    RETURN response

                ELSE:

                    log("error: No data recived")

                    RETURN {"requestType":None}

        except socket.timeout:

            RETURN {"requestType":None}



        except Exception as e:

            log("error",e)

            RETURN {"requestType":None}



    DEFINE FUNCTION connect(self,username,password):

        #Connects to the server and attempts to login. Returns true IF logged in.

        log("Attempting to connect to server")

        TRY:

            self.client.connect(self.addr)

            SET self.connected TO True

            log("Sucsessfully connected to server")

        except Exception as e:

            log("Failed to connect to server",e)

            RETURN False



        log("Attempting login")

        SET self.username,self.access TO self.login(username,password)



        IF self.username EQUALS None:

            log("Login failed")

            RETURN False

        

        ELSEIF self.username != None:

            log("Login sucsessful, gathering online users")

            self.getOnlineUsers()

            self.client.settimeout(.5)

            RETURN True



    DEFINE FUNCTION startLoop(self,loop):

        #This method will start the nessecary loops 

        IF loop EQUALS "menu":

            log("Starting menu loop")

            SET self.menu TO True

            SET menuThread TO threading.Thread(target=self.menuLoop)

            menuThread.start()



        ELSEIF loop EQUALS "battle":

            log("Starting battle loop")

            SET self.battle TO True

            SET battleThread TO threading.Thread(target=self.battleLoop)

            battleThread.start()



    DEFINE FUNCTION getOnlineUsers(self):

        self.send({"requestType":"getOnlineUsers"})



        #Will remove itself from lust of online users before RETURNing the list

        FOR user IN self.onlineUsers:

            IF user EQUALS self.username:

                self.onlineUsers.remove(user)

        RETURN self.onlineUsers



    DEFINE FUNCTION menuLoop(self):

        #Handle requests when user is IN menu

        WHILE self.menu:

            SET response TO self.receive()

            IF response != None and type(response) EQUALS dict:



                IF response["requestType"]=="battleReq":

                    log("Battle request recived...")

                    SET self.pendingEnemy TO response["enemyU"]

                    SET self.pendingBattle TO True



                ELSEIF response["requestType"] EQUALS "battleConfirm" and response["battleAccepted"] EQUALS True:

                    log("Starting battle")

                    SET self.startSide TO response["startSide"]

                    SET self.enemyUsername TO response["enemyU"]

                    SET self.menu TO False



                ELSEIF response["requestType"] EQUALS "getOnlineUsers":

                    SET self.onlineUsers TO response["onlineUsers"]



        RETURN None

    

    DEFINE FUNCTION checkPendingBattle(self):

        RETURN self.pendingBattle



    DEFINE FUNCTION checkPendingEnemy(self):

        RETURN self.pendingEnemy



    DEFINE FUNCTION getEnemyStartside(self):

        IF self.enemyUsername != None:

            RETURN self.enemyUsername, self.startSide 

        ELSE:

            RETURN None, None



    DEFINE FUNCTION sendBattleReq(self,enemyU): 

        #gets a list of online users then sends battle request with provided username IF user is online

        SET sent TO False

        SET self.requestedEnemy TO enemyU

        log("Enemy request ready")

        FOR username IN self.onlineUsers: #Checks IF user is online

            IF self.requestedEnemy.lower() EQUALS username.lower():

                log("Sending battle request")

                self.send({"requestType":"startBattle","enemyU":self.requestedEnemy})

                SET sent TO True

        IF sent EQUALS False:

            log("Requested user not online")

            SET self.requestedEnemy TO None

                               

    DEFINE FUNCTION login(self,username,password): 

        #create login request

        SET loginReq TO {"requestType":"loginRequest","username":username,"password":password}



        #Send request

        self.send(loginReq)



        #Receive response

        SET response TO self.receive()



        IF response EQUALS None or type(response) != dict:

            RETURN None, None



        #if login was sucsessful, RETURN username and acsess

        IF response["requestType"]=="loginRequest" and response["loginR"]==True: 

            log("Server accepted login response")

            RETURN username, response["access"]



        ELSE:

            RETURN None, None



    DEFINE FUNCTION enemyConnected(self):

        #if enemy username is not none, user is connected

        IF self.enemyUsername != None:

            RETURN True

        ELSE:

            RETURN False

    

    DEFINE FUNCTION acceptBattle(self):

        log("Accepting battle")

        SET self.requestedEnemy TO self.pendingEnemy

        SET accept TO {"requestType":"battleReq","battleAccepted":True,"enemyU":self.pendingEnemy} 

        self.send(accept)



    DEFINE FUNCTION battleLoop(self):

        #handle all data being recived during a battle

        WHILE self.battle:

            SET data TO self.battleReceive()

            IF data != None and type(data) EQUALS dict:

                IF data["requestType"] EQUALS "posData":



                    #game loop might fetch pos data and miss this data, so it is stored IN network as an attribute 

                    IF "clickPos" IN data:  

                        SET self.enemyClick TO data["clickPos"]

                    SET self.enemyData TO data



                IF data["requestType"] EQUALS "opponentDisconnect":

                    self.endBattle()

                IF data["requestType"] EQUALS "gameOver":

                    OUTPUT("gameOver")

                    self.endBattle()

            ELSE:

                log("error: no data")

            

            SET data TO self.data

            IF data != None:

                IF self.click != None:

                    SET data["clickPos"] TO self.click

                    SET self.click TO None

                self.send(data)



    DEFINE FUNCTION endBattle(self):

        #reset all battle related attributes FOR next battle

        SET self.battle TO False

        SET self.requestedEnemy TO None

        SET self.enemyClick TO None

        SET self.enemyUsername TO None

        SET self.startside TO None

        SET self.pendingBattle TO False

        SET self.pendingEnemy TO None

        self.startLoop("menu")



    DEFINE FUNCTION getAccess(self):

        RETURN json.loads(self.access)



    DEFINE FUNCTION getEnemyData(self):

        SET data TO self.enemyData

        IF self.enemyClick != None:

            SET data["clickPos"] TO self.enemyClick

            SET self.enemyClick TO None

        RETURN data



    DEFINE FUNCTION updateData(self,data):

        SET self.data TO data

        IF "clickPos" IN data:

            SET self.click TO data["clickPos"]

   

    DEFINE FUNCTION isConnected(self):

        RETURN self.connected

    
