IMPORT os

IMPORT pygame

IMPORT sys



from ui IMPORT Button, HealthBar, InputBox, OnlineList

from client_network IMPORT Network



DEFINE FUNCTION log(event):

    OUTPUT("log: ", event)





DEFINE CLASS Controls():

    DEFINE FUNCTION __init__(self):

        #Currently set to arrow keys as default

        SET self.jump TO pygame.K_UP

        SET self.crouch TO pygame.K_DOWN

        SET self.left TO pygame.K_LEFT

        SET self.right TO pygame.K_RIGHT



    DEFINE FUNCTION change():

        #This can be expanded later IF necessary 

        PASS



    DEFINE FUNCTION loadSettings():

        #This can be expanded later IF necessary 

        PASS    



DEFINE CLASS Textures:

    DEFINE FUNCTION __init__(self,width,height):

        SET self.width TO width

        SET self.height TO height

        #Login background will be loaded seperatley, because acsess is not available untill after login

        SET self.loginBackground TO pygame.image.load(os.path.join("textures", "background.png"))

        SET self.loginBackground TO pygame.transform.scale(self.loginBackground,(width, height))



    DEFINE FUNCTION getLoginBackground(self):

        #Returns login background

        RETURN self.loginBackground



    DEFINE FUNCTION loadTextures(self,acsess):

        #Textures and animations that are required

        SET textures TO ["standing","enemyStanding","background","crouching","enemyCrouching","jumping","enemyJumping"]

        SET animations TO ["walking","enemyWalking"]



        #Empty dictionaries FOR loaded textures

        SET loadedTextures TO {}

        SET loadedAnimations TO {}



        #This loop will load each texture depending on the acsess given 

        FOR texture IN textures: 

            TRY:

                SET loadedTextures[texture] TO pygame.image.load(os.path.join("textures", acsess[texture]+".png"))

            EXCEPT:

                log("texture not found: "+texture)

            

        #This loop will load each animation depending on the acsess given

        FOR animation IN animations:

            SET loadedAnimations[animation] TO []

            #animations will always have 4 images

            FOR i IN range(4):

                TRY:

                    loadedAnimations[animation].append(pygame.image.load(os.path.join("textures",acsess[animation], str(i)+".gif")))

                EXCEPT:

                    log("animation not found: "+animation) 

        

        #Resize background to window size

        TRY:

            SET loadedTextures["background"] TO pygame.transform.scale(loadedTextures["background"],(self.width, self.height))

        EXCEPT:

            log("No background")



        #Return loaded textures

        RETURN loadedTextures, loadedAnimations     



DEFINE CLASS Player(pygame.sprite.Sprite):

    DEFINE FUNCTION __init__(self,x,y,r,g,b,game,cType,startside):



        #sprite init function (required by pygame)

        pygame.sprite.Sprite.__init__(self) 



        #set attributes

        SET self.playerWidth TO 120

        SET self.playerHeight TO 240

        SET self.game TO game

        SET self.state TO "standing"

        SET self.y TO self.game.height - 140 -self.playerHeight/2 

        SET self.color TO r,g,b

        SET self.vel TO 10

        SET self.hp TO 100



        #Charachter must be spawned IN the correct location which is decided by the server

        IF startside EQUALS "L":

            SET self.orientation TO "R" 

            SET self.x TO self.game.width/4

        ELSE:

            SET self.orientation TO "L"

            SET self.x TO self.game.width*3/4         



        

        #CREATING CHARACHTER

        IF cType EQUALS "p":

            SET self.image TO self.game.textures["standing"]

        IF cType EQUALS "e":

            SET self.image TO self.game.textures["enemyStanding"]

        IF self.orientation EQUALS "L":

            SET self.image TO pygame.transform.flip(self.image, True, False)

        SET self.rect TO self.image.get_rect() #will  define players hitbox as size of the image

        SET self.rect.center TO (self.x, self.y)



    

        #FOR JUMPING (can be changed)

        SET self.jumpcount TO 10

        SET self.doubleJumpCount TO 10

        SET self.doubleJumpsAllowed TO 3

        SET self.jumpsize TO 4 # THE BIGGER THE VALUE THE SMALLER THE JUMP



        #CONSTANTS (do not change)

        SET self.jumping TO False

        SET self.doubleJumps TO 0

        SET self.readyForDoubleJump TO False

        SET self.startingY TO game.height -self.playerHeight/2 

        SET self.changeList TO []

        SET self.counter TO 0

        SET self.walkcounter TO 0



    DEFINE FUNCTION reudceHp(self, ammount):

        #Reduce hp by given ammount

        self.hp -= ammount

    



    DEFINE FUNCTION move(self):

        SET wait TO 1



        SET keys TO pygame.key.get_pressed()



        #state is reset to standing after each loop

        SET self.state TO "standing"



        #Left movment

        IF keys[self.game.controls.left] and self.x > self.vel + self.playerWidth/2:

            self.x -= self.vel

            SET self.state TO "walking"

            SET self.orientation TO "L"



        #Right movment

        IF keys[self.game.controls.right] and self.x < g.width - self.vel - self.playerWidth/2 :

            self.x += self.vel

            SET self.state TO "walking"

            SET self.orientation TO "R"



        #Initiate a jump

        IF keys[self.game.controls.jump] and self.y > self.vel + self.playerHeight/2 and self.jumping EQUALS False:

            SET self.jumping TO True

            SET self.startingY TO self.y

            SET wait TO 0



        #Crouch

        IF keys[pygame.K_DOWN] and self.jumping EQUALS False:

            SET self.state TO "crouching"

            PASS

        

        #Jump mechanics

        IF self.jumping EQUALS True and wait EQUALS 1:



            #for jumping texture

            SET self.state TO "jumping"



            #increment jump counter

            self.counter +=1



            #while the player is increasing height

            IF self.jumpcount > 0 and self.counter%2 EQUALS 0: 

                #Quadradic formula FOR jump used to calculate correct position changfe

                SET change TO self.jumpcount * self.jumpcount/self.jumpsize 



                #Apply change

                self.y -= change

                

                #Record change on change list

                self.changeList.append(change)

                

                #reduce jumpcount

                self.jumpcount -= 1



            #arm double jump

            IF not keys[pygame.K_UP]:

                SET self.readyForDoubleJump TO True



            #Double jump

            IF self.doubleJumps < self.doubleJumpsAllowed and keys[pygame.K_UP] and self.readyForDoubleJump EQUALS True:

                self.doubleJumps += 1

                SET self.jumpcount TO self.doubleJumpCount

                SET self.readyForDoubleJump TO False



            #once player has reached highest point, reverse the changes made to RETURN player to the ground

            IF self.jumpcount EQUALS 0 and self.y != self.startingY and self.counter%2 EQUALS 0:

                self.y += self.changeList.pop(self.changeList.index(min(self.changeList)))



            #Reset everything once player is on the ground

            IF self.jumpcount EQUALS 0 and not self.changeList: 

                SET self.jumpcount TO 10 

                SET self.doubleJumps TO 0

                SET self.counter TO 0

                SET self.readyForDoubleJump TO False

                SET self.jumping TO False

        

        #Load correct texture depending on state

        IF self.state EQUALS "jumping":

            SET self.image TO self.game.textures["jumping"]

        IF self.state EQUALS "crouching":

            SET self.image TO self.game.textures["crouching"]

        IF self.state EQUALS "standing":

            SET self.image TO self.game.textures["standing"]

        IF self.state EQUALS "walking":

            #Play walk animation

            IF self.walkcounter >= 3:

                SET self.walkcounter TO 0

            SET self.image TO self.game.animations["enemyWalking"][self.walkcounter]

            self.walkcounter += 1



        #Adjust texture based on orientation

        IF self.orientation EQUALS "L":

            SET self.image TO pygame.transform.flip(self.image, True, False)



        #Finalise chanegs to charachter rect

        SET self.rect.center TO (self.x, self.y)





    

    DEFINE FUNCTION dataUpdate(self,data):

        #Takes the enemys data as a paramater and updates charachter accoordingly    

        SET self.x TO data["x"]

        SET self.y TO data["y"]

        SET self.state TO data["state"]

        SET self.orientation TO data["orientation"]

        SET self.hp TO data["hp"]

        

        IF self.state EQUALS "jumping":

            SET self.image TO self.game.textures["enemyJumping"]

        IF self.state EQUALS "crouching":

            SET self.image TO self.game.textures["enemyCrouching"]

        IF self.state EQUALS "standing":

            SET self.image TO self.game.textures["enemyStanding"]

        IF self.state EQUALS "walking":

            IF self.walkcounter >= 3:

                SET self.walkcounter TO 0

            SET self.image TO self.game.animations["enemyWalking"][self.walkcounter]

            self.walkcounter += 1



        IF self.orientation EQUALS "L":

            SET self.image TO pygame.transform.flip(self.image, True, False)



        #Finalise chanegs to charachter rect

        SET self.rect.center TO (self.x, self.y)



    DEFINE FUNCTION getPos(self):

        #RETURN player data to be sent to the server

        RETURN {"requestType":"posData","x":self.x,"y":self.y,"state":self.state,"orientation":self.orientation,"hp":self.hp}





    DEFINE FUNCTION getHP(self):

        #RETURN hp

        RETURN self.hp



    DEFINE FUNCTION checkClick(self,clickpos,enemyPos):

        #Check IF the click was on the sprite

        IF self.rect.collidepoint(clickpos):



            #check how close enemy is

            SET xDistance TO abs(self.x-enemyPos[0])

            SET yDistance TO abs(self.y-enemyPos[1])



            IF xDistance < 200 and yDistance < 200:

                #reduce hp

                self.reudceHp(10)



        #check IF user has died

        IF self.hp <= 0:

            RETURN False

        ELSE:

            RETURN True



DEFINE CLASS Game():

    DEFINE FUNCTION __init__(self):

        log("Initializing game")

        #init pygame

        pygame.init()

        #init controls object

        SET self.controls TO Controls()

        #init network object

        SET self.n TO Network()

        #init textures  object

        SET self.textureObject TO Textures(self.width,self.height)



        #game attributes

        SET self.width TO 1280

        SET self.height TO 720



        #pygame window

        SET self.win TO pygame.display.set_mode((self.width,self.height))

        pygame.display.set_caption("Client")





        log("Game initialized")





    



    DEFINE FUNCTION renderBattle(self,win,all_sprites):

        all_sprites.update() #update sprites

        pygame.display.update() #uptade display

        win.fill((255,255,255))

        self.win.blit(self.textures["background"], (0, 0)) #draw background

        all_sprites.draw(win) #DRAW SPRITES

    



    

    DEFINE FUNCTION loginScreen(self):

        #Menu UI

        SET buttons TO [Button("Login",self.width/2,self.height/2+70,(0,0,0),150,100)]

        SET INPUTBoxes TO [InputBox(self.width/2-30, (self.height/2)-100+25, 140, 32),InputBox(self.width/2-30, (self.height/2)-100-25, 140, 32)]





        #Menu loop

        SET loginScreen TO True

        log("Login Screen loaded")

        WHILE loginScreen:

            FOR event IN pygame.event.get(): #Event handler



                IF event.type EQUALS pygame.QUIT: #check IF user has closed the game

                    SET loginScreen TO self.exit()

                    break

                

                FOR box IN INPUTBoxes: 

                    box.handle_event(event) #handle INPUT box events



                IF event.type EQUALS pygame.MOUSEBUTTONDOWN: #handle button events

                    SET pos TO pygame.mouse.get_pos()

                    FOR button IN buttons:

                        IF button.click(pos): #if a button is clicled chech which one



                            IF button.text EQUALS "Login": 

                                log("Attempting to connect to server")

                                IF self.n.connect(INPUTBoxes[1].text,INPUTBoxes[0].text): #attempts to connect with given username and password)

                                    log("Connected")

                                    SET self.acsess TO self.n.getAcsess()

                                    self.mainMenu()



                                    

            #Draw Login screen

            self.win.fill((255,255,255))

            SET background TO self.textureObject.getLoginBackground()

            self.win.blit(background,(0, 0))

            SET font TO pygame.font.Font('freesansbold.ttf',115)

            SET textSurface TO font.render('Login', True, (0,0,0))

            SET TextRect TO textSurface.get_rect()

            SET TextRect.center TO ((self.width/2),(self.height/6))

            self.win.blit(textSurface, TextRect)



            #Update INPUT boxes

            FOR box IN INPUTBoxes:

                box.update()



            #Draw Buttons

            FOR button IN buttons:

                button.draw(self.win)



            #Draw INPUT boxes

            FOR box IN INPUTBoxes:

                box.draw(self.win)

            





            #Update Display

            pygame.display.update()





    DEFINE FUNCTION mainMenu(self):

        #Menu UI

        SET self.textures,self.animations TO self.textureObject.loadTextures(self.acsess)

        

        SET onlineList TO OnlineList(self.width/8,70)

        SET requestBox TO None

        #Menu loop

        self.n.startLoop("menu")

        SET onlineUsers TO self.n.getOnlineUsers()

        onlineList.updateUsers(onlineUsers)

        SET menuScreen TO True





        log("Menu loaded")

        WHILE menuScreen:

        

            FOR event IN pygame.event.get(): #Event handler



                IF event.type EQUALS pygame.QUIT: 

                    SET menuScreen TO self.exit()

                    break

    



                IF event.type EQUALS pygame.MOUSEBUTTONDOWN: #handle button events



                    SET onlineUsers TO self.n.getOnlineUsers() #done when mouse clicked only to avoid too many requests



                    onlineList.updateUsers(onlineUsers)

                    

                    SET pos TO pygame.mouse.get_pos()

                    

                    #if there is a request box, and it is clicked, accept pending battle

                    IF requestBox != None:

                        IF requestBox.click(pos):

                            self.n.acceptBattle() 



                    #check IF a request has been made        

                    SET eRequest TO onlineList.click(pos)

                    IF eRequest != None and self.n.isConnected():

                        #if a request was made, attempt to send to server

                        log("Attempting to start battle")

                        self.n.sendBattleReq(eRequest)

                                





                                    

            IF self.n.isConnected():

                #Check IF a battle request whas been recived

                IF self.n.checkPendingBattle() EQUALS True:

                    #Display battle request

                    SET requestBox TO Button("Battle request from: "+ self.n.checkPendingEnemy(),900,600,(255,0,0),350,100)

                

                #check IF enemy user is ready to battle

                SET enemyU, startSide TO self.n.getEnemyStartside()

                IF enemyU != None: #if user is ready to battle

                    log("Loading battle")

                    self.battle(enemyU,startSide)



                    #after battle is complete, reset all variables

                    SET enemyU TO None

                    SET startSide TO None

                    SET requestBox TO None





            #Draw Menu screen

            self.win.fill((255,255,255))

            self.win.blit(self.textures["background"], (0, 0))     

            SET font TO pygame.font.Font('freesansbold.ttf',20)

            SET textSurface TO font.render('Online Users', True, (0,0,0))

            SET TextRect TO textSurface.get_rect()

            SET TextRect.center TO ((self.width/8),(50))

            self.win.blit(textSurface, TextRect)



            #Draw reuqests

            IF requestBox != None:

                requestBox.draw(self.win)



            #Draw online list

            onlineList.draw(self.win)



            #Update Display

            pygame.display.update()

        





    DEFINE FUNCTION battle(self,enemyU,startSide):





        #initiate sprites

        SET all_sprites TO pygame.sprite.Group()

        IF startSide EQUALS "L":

            SET p TO Player(50,50,0,255,0,self,"p","L")

            SET e TO Player(50,50,255,0,0,self,"e","R")

            SET healthbarP TO HealthBar(50,50,50)

            SET healthbarE TO HealthBar(50,1020,50)

        ELSE:

            SET p TO Player(50,50,0,255,0,self,"p","R")

            SET e TO Player(50,50,255,0,0,self,"e","L")

            SET healthbarE TO HealthBar(50,50,50)

            SET healthbarP TO HealthBar(50,1020,50)



        #add sprites to sprite list

        all_sprites.add(p)

        all_sprites.add(e)



        

        SET run TO True

        log("Battle loaded")

        self.n.startLoop("battle")



        WHILE run and self.n.isConnected() and self.n.enemyConnected():

            SET clickPos TO None

            pygame.time.delay(20)



            FOR event IN pygame.event.get():

                IF event.type EQUALS pygame.QUIT:

                    SET run TO not self.exit()

                

                IF event.type EQUALS pygame.MOUSEBUTTONDOWN:

                    SET clickPos TO pygame.mouse.get_pos()

                            



            

            p.move() #checks FOR key prsses, and moves charachter



           #Network handler



            TRY:

                #Get player data 

                SET playerData TO p.getPos()



                #if player clicked, add click pos to data

                IF clickPos != None:

                    SET playerData["clickPos"] TO clickPos



                #pass player data to network to be sent

                self.n.updateData(playerData)



                #Update enemy data

                SET enemyData TO self.n.getEnemyData()

                IF enemyData != None:   

                    e.dataUpdate(enemyData)

                    IF "clickPos" IN enemyData: #check IF enemy has dine damage to you

                        p.checkClick(enemyData["clickPos"],(enemyData["x"],enemyData["y"]))





            except Exception as exc:

                log(exc)



            #Update health bar

            healthbarP.updateHealth(p.getHP())

            healthbarE.updateHealth(e.getHP())



            #Draw health bar

            healthbarP.draw(self.win)

            healthbarE.draw(self.win)



            #Render battle

            self.renderBattle(self.win,all_sprites) #Render battle





        

    DEFINE FUNCTION exit(self):

        pygame.quit()

        sys.exit()

        RETURN True





SET g TO Game()

g.loginScreen()
